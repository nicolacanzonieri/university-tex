\section{Capitolo 1}

\subsection{Introduzione e Problemi di ordinamento}

\begin{flushleft}

I problemi di ordinamento consistono nell'ordinare una data sequenza di interi, contenuta in un vettore
di interi $A$ di lunghezza $n$.

Vedremo una serie di algoritmi che si occuperanno di svolgere questo problema e in particolare andremo
a studiare la \textbf{complessità spaziale, temporale} e la \textbf{correttezza} di questi algoritmi.

\end{flushleft}

\subsection{Insertion Sort}

\begin{flushleft}

L'idea alla base dell'algoritmo Insertion Sort è quella che dato un vettore $A$ dove sappiamo che
$A[1 ... i-1]$ è già ordinato, per ordinare tutto $A[1...i]$ ci basterà inserire $A[i]$ nel posto giusto.

Possiamo applicare questa strategia pensando già da subito che il vettore $A[1 ... 1]$ è già ordinato
e che quindi ci basterà iniziare a posizionare $A[2]$ e così via.

$\newline$

Questo è lo pseudocodice di Insertion Sort:

\begin{lstlisting}

InsertionSort(A) {
	for (i <- 2 to n) {
		key <- A[i]
		j <- i - 1
		
		while (key < A[j] and j > 0) {
			A[j + 1] <- A[j]
			j <- j - 1
		}
		
		A[j + 1] <- key
	}
}

\end{lstlisting}
\end{flushleft}

\subsection{Complessità temporale di Insertion Sort}

\begin{flushleft}

Analizziamo adesso la complessità temporale di Insertion Sort andando a costruire la funzione che
ci ritornerà il tempo di esecuzione che l'algoritmo necessita:

\medskip

\codewords{for (i <- 2 to n)} necessita tempo $c_1 + c_2 (n - 1)$

\medskip

\codewords{key <- A[i]} necessita tempo $c_3 (n - 1)$

\medskip

\codewords{j <- i - 1} necessita tempo $c_4 (n - 1)$

\medskip

\codewords{while (key < A[j] and j > 0)} necessita tempo $c_5 \sum_{i = 2}^{n}t_i$ 
dove $t_i$ indica il numero di volte che l'intestazione viene eseguita durante la 
$i$-esima iterazione del \codewords{for}

\medskip

\codewords{A[j + 1] <- A[j]} necessita tempo $c_6 \sum_{i = 2}^{n}(t_i - 1)$

\medskip

\codewords{j <- j - 1} necessita tempo $c_7 \sum_{i = 2}^{n}(t_i - 1)$

\medskip

\codewords{A[j + 1]} necessita tempo $c_8 (n - 1)$

\medskip

Sommando tutti i termini $c_i$ abbiamo che:

\begin{equation*}
\resizebox{\textwidth}{!}{
$T_{Insert}(n) = c_1 + c_2(n-1) + c_3(n-1) + c_4(n-1) + c_5 \sum_{i = 2}^n t_i + c_6 \sum_{i = 2}^n (t_i-1) 
+ c_7 \sum_{i = 2}^n (t_i-1) + c_8(n-1)$
}
\end{equation*}

Che possiamo semplificare in:

\[ T_{Insert}(n) = a + b(n-1) + c \sum_{i = 2}^n t_i\]

Da questa nuova equazione (molto più maneggiabile) possiamo analizzare il tempo necessario per la computazione
dell'algoritmo Insertion Sort nel \textbf{caso peggiore} e nel caso \textbf{caso minore}.

\medskip

Per quanto riguarda il \textbf{caso peggiore} possiamo subito dire che questo caso corrisponde al caso
in cui il vettore è ordinato in ordine decrescente e quindi avremo che $t_i = i$ da cui vediamo che:

\[ \sum_{i = 2}^{n} i = \frac {n (n+1)} {2} - 1 \]

e quindi:

\[ T_{Insert}(n) = a + b(n-1) + c \frac{n (n+1)}{n} - c = \Theta(n^2)\]

che vuol dire che la complessità temporale nel caso peggiore è \textbf{quadratica}.

\medskip

Nel \textbf{caso migliore} il vettore è già ordinato e quindi $t_i = 1$ poiché l'intestazione del while
viene eseguita comunque una volta per il confronto. Quindi abbiamo che:

\[ T_{Insert} = a + b(n-1) + c(n-1) = \Theta(n) \]

che vuol dire che la complessità temporale nel caso migliore è \textbf{lineare}.

\end{flushleft}

\subsection{Complessità spaziale e stabilità di Insertion Sort}

\begin{flushleft}

Lo spazio richiesto dall'algoritmo (cioè il numero di variabili presenti) non dipende dalla grandezza del
vettore $A$ (infatti le variabili sono sempre \codewords{i}, \codewords{j} e \codewords{key}). Per questo 
motivo abbiamo che:

\[ S_{Insert}(n) = \Theta(1)\]

che vuol dire che la complessità spaziale è \textbf{costante} e quindi si dice anche che Insertion Sort è un
algoritmo \textbf{in place}.

\bigskip

Un altro concetto molto importante è quello della \textbf{stabilità}, infatti un algoritmo di ordinamento
che fa si che gli elementi ripetuti restino nello stesso ordine viene detto \textbf{algoritmo stabile}.

\end{flushleft}

\subsection{Correttezza di Insertion Sort}

\begin{flushleft}

Dobbiamo dimostrare che $\forall A$, \codewords{InsertionSort(A)} termina con $A$ ordinato. Questo
corrisponde al nostro \textbf{enunciato di correttezza}.

\medskip

Per procedere abbiamo bisogno di un \textbf{invariante} per il ciclo \codewords{for} che risponderà alla
domanda: "Alla $i$-esima iterazione del ciclo \codewords{for}, cos'è sempre vero?".

La risposta sarà: "All'inizio della $i$-esima iterazione del \codewords{for}, $A[1...i-1]$ è ordinato".

Dimostriamolo per induzione su $i$:

\medskip

\textbf{Caso base: i = 2}

$A[1...i-1] = A[1...1]$ è ordinato poiché è composto da un unico elemento

\medskip

\textbf{Passo induttivo}

Supponiamo che alla $i$-esima iterazione $A[1...i-1]$ sia ordinato, e dimostriamo che $A[1...i]$ verrà ordinato
alla $i+1$-esima iterazione.

Analizzando il corpo del ciclo \codewords{for} vediamo che il ciclo \codewords{while} sposta a dx gli elementi 
senza modificare l'ordine. Infatti tutti i valori prima del $j$-esimo (una volta che il ciclo while si è 
interrotto) sono ordinati e la stessa cosa vale per quelli dopo.

Per questo motivo il valore che verrà inserito nel $j$-esimo posto sarà maggiore di tutti quelli prima di lui
e minore di tutti quelli dopo di lui.

Inoltre poiché la guardia del ciclo for (vale a dire $i$) non è stata toccata all'interno del ciclo stesso
possiamo essere sicuri che il for terminerà all'inizio della $(n+1)$-esima iterazione per l'invariante avremo
che $A[1...(n+1)-1] = A[1...n]$ è ordinato.

\end{flushleft}